# -*- coding: utf-8 -*-
"""HybridAlgoCiphers.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/deannos/Project-IV/blob/master/HybridAlgoCiphers.ipynb

# Implementation of **Polybius Cipher** :-

[Reference](https://www.diva-portal.org/smash/get/diva2:1664395/FULLTEXT01.pdf) for Polybius Cipher better Understanding.

# Time complexity -

[1] Time Complexity of Encryption:
 - The encrypt function iterates over each character in the plaintext, and for each character, it searches for its position in the grid. This involves iterating through each row of the grid. Therefore, the time complexity of the encrypt function can be approximated as **O(n*m)**, where n is the length of the plaintext and m is the number of rows in the grid.

[2] Time Complexity of Decryption:- 
- The decrypt function iterates over the ciphertext in steps of 2 and performs a constant time lookup in the grid to find the corresponding character.Therefore, the time complexity of the decrypt function can be approximated as **O(n/2)**, where n is the length of the ciphertext.

[3] Overall Time Complexity:

- Overall, the time complexity of both encryption and decryption functions can be considered as **O(n)**, where n is the length of the input text.

[4] Space Complexity:

 - The space complexity of the encrypt function is **O(1)** since it uses a constant amount of additional memory to store variables.
 - The space complexity of the decrypt function is also **O(1)** since it uses a constant amount of additional memory to store variables.
 - Overall, the space complexity of the code is **O(1)**, indicating that the additional memory used does not scale with the input size.
"""

class PolybiusCipher:
    def __init__(self):
        self.grid = [['A', 'B', 'C', 'D', 'E'],
                     ['F', 'G', 'H', 'I/J', 'K'],
                     ['L', 'M', 'N', 'O', 'P'],
                     ['Q', 'R', 'S', 'T', 'U'],
                     ['V', 'W', 'X', 'Y', 'Z']]

    def encrypt(self, plaintext):
        ciphertext = ''
        plaintext = plaintext.upper()

        for char in plaintext:
            if char == 'J':
                char = 'I'

            for row in self.grid:
                if char in row:
                    row_index = self.grid.index(row)
                    col_index = row.index(char)
                    ciphertext += str(row_index + 1) + str(col_index + 1)
                    break

        return ciphertext

    def decrypt(self, ciphertext):
        plaintext = ''
        ciphertext = ciphertext.upper()

        for i in range(0, len(ciphertext), 2):
            row_index = int(ciphertext[i]) - 1
            col_index = int(ciphertext[i+1]) - 1
            plaintext += self.grid[row_index][col_index]

        return plaintext


cipher = PolybiusCipher()
plaintext = "give me a call"
encrypted_text = cipher.encrypt(plaintext)
decrypted_text = cipher.decrypt(encrypted_text)

print("Plaintext:", plaintext)
print("Encrypted Text:", encrypted_text)
print("Decrypted Text:", decrypted_text)

"""# Implementation of Vigenere Cipher :-

# Time Complexity :-

[1] Time Complexity of Encryption:

 - The encrypt function iterates over each character in the plaintext and performs operations on it. For each character, it performs constant time operations like finding the index of the key character and performing modular arithmetic. Therefore, the time complexity of the encrypt function can be approximated as **O(n)**, where n is the length of the plaintext.

[2] Time Complexity of Decryption:- 
- The decrypt function also iterates over each character in the ciphertext and performs operations on it. Similar to encryption, it performs constant time operations for each character. Therefore, the time complexity of the decrypt function can be approximated as **O(n)**, where n is the length of the ciphertext.

[3] Overall Time Complexity:

 - As both the encryption and decryption functions have a time complexity of **O(n)**, where n is the length of the input text, the overall time complexity of the code is also **O(n)**.




"""

class VigenereCipher:
    def __init__(self):
        self.alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

    def encrypt(self, plaintext, key):
        ciphertext = ''
        plaintext = plaintext.upper()
        key = key.upper()
        key_index = 0

        for char in plaintext:
            if char in self.alphabet:
                shift = self.alphabet.index(key[key_index])
                encrypted_char = self.alphabet[(self.alphabet.index(char) + shift) % 26]
                ciphertext += encrypted_char
                key_index = (key_index + 1) % len(key)
            else:
                ciphertext += char

        return ciphertext

    def decrypt(self, ciphertext, key):
        plaintext = ''
        ciphertext = ciphertext.upper()
        key = key.upper()
        key_index = 0

        for char in ciphertext:
            if char in self.alphabet:
                shift = self.alphabet.index(key[key_index])
                decrypted_char = self.alphabet[(self.alphabet.index(char) - shift) % 26]
                plaintext += decrypted_char
                key_index = (key_index + 1) % len(key)
            else:
                plaintext += char

        return plaintext


cipher = VigenereCipher()
plaintext = "give me a call"
# Note - We cannot use white space for KEY string 
key = "Hi"
encrypted_text = cipher.encrypt(plaintext, key)
decrypted_text = cipher.decrypt(encrypted_text, key)

print("Plaintext:", plaintext)
print("Encrypted Text:", encrypted_text)
print("Decrypted Text:", decrypted_text)

"""# Implementation of Both Ciphers :- Polybius & Vigenere [Hybrid Algorithm]

[1] PolybiusCipher:

 - The encrypt function iterates over each character in the plaintext and performs a linear search through the grid to find the corresponding indices. Therefore, the time complexity of the encrypt function can be approximated as **O(n * m)**, where n is the length of the plaintext and m is the number of rows in the grid.
 - The decrypt function iterates over the ciphertext in steps of 2 and performs constant time operations to retrieve the characters from the grid. Therefore, the time complexity of the decrypt function can be approximated as **O(n/2)**, where n is the length of¬†the¬†ciphertext.

[2] VigenereCipher:

 - The encrypt function iterates over each character in the plaintext and performs constant time operations such as finding indices and performing modular arithmetic. Therefore, the time complexity of the encrypt function can be approximated as **O(n)**, where n is the length of the plaintext.
 - The decrypt function also iterates over each character in the ciphertext and performs constant time operations. Therefore, the time complexity of the decrypt function can be approximated as **O(n)**, where n is the length of the ciphertext.

[3] Overall Time Complexity:
- In the main function, both the Polybius Cipher and Vigen√®re Cipher operations are called separately. Thus, the time complexity of the entire code can be considered as the sum of the time complexities of the Polybius Cipher and Vigenere Cipher operations. Since the operations in both ciphers have linear or constant time complexity, the overall time complexity of the code can be approximated as *O(n)* , where n is the length of¬†the¬†input¬†text.


"""

class PolybiusCipher:
    def __init__(self):
        self.grid = [['A', 'B', 'C', 'D', 'E'],
                     ['F', 'G', 'H', 'I', 'K'],
                     ['L', 'M', 'N', 'O', 'P'],
                     ['Q', 'R', 'S', 'T', 'U'],
                     ['V', 'W', 'X', 'Y', 'Z']]

    def encrypt(self, plaintext):
        ciphertext = ''
        plaintext = plaintext.upper()

        for char in plaintext:
            if char == 'J':
                char = 'I'

            for row in self.grid:
                if char in row:
                    row_index = self.grid.index(row)
                    col_index = row.index(char)
                    ciphertext += str(row_index + 1) + str(col_index + 1)
                    break

        return ciphertext

    def decrypt(self, ciphertext):
        plaintext = ''
        ciphertext = ciphertext.upper()

        for i in range(0, len(ciphertext), 2):
            row_index = int(ciphertext[i]) - 1
            col_index = int(ciphertext[i+1]) - 1
            plaintext += self.grid[row_index][col_index]
        return plaintext


class VigenereCipher:
    def __init__(self):
        self.alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

    def encrypt(self, plaintext, key):
        ciphertext = ''
        plaintext = plaintext.upper()
        key = key.upper()
        key_index = 0
        for char in plaintext:
            if char in self.alphabet:
                shift = self.alphabet.index(key[key_index])
                encrypted_char = self.alphabet[(self.alphabet.index(char) + shift) % 26]
                ciphertext += encrypted_char
                key_index = (key_index + 1) % len(key)
            else:
                ciphertext += char
        return ciphertext

    def decrypt(self, ciphertext, key):
        plaintext = ''
        ciphertext = ciphertext.upper()
        key = key.upper()
        key_index = 0

        for char in ciphertext:
            if char in self.alphabet:
                shift = self.alphabet.index(key[key_index])
                decrypted_char = self.alphabet[(self.alphabet.index(char) - shift) % 26]
                plaintext += decrypted_char
                key_index = (key_index + 1) % len(key)
            else:
                plaintext += char

        return plaintext


def main():
    polybius_cipher = PolybiusCipher()
    vigenere_cipher = VigenereCipher()

    plaintext = "your account No is 24643"
    polybius_encrypted_text = polybius_cipher.encrypt(plaintext)
    polybius_decrypted_text = polybius_cipher.decrypt(polybius_encrypted_text)

    key = "KEY"
    vigenere_encrypted_text = vigenere_cipher.encrypt(plaintext, key)
    vigenere_decrypted_text = vigenere_cipher.decrypt(vigenere_encrypted_text, key)

    print("Plaintext:", plaintext)
    print("Polybius Encrypted Text:", polybius_encrypted_text)
    print("Polybius Decrypted Text:", polybius_decrypted_text)
    print("Vigen√®re Encrypted Text:", vigenere_encrypted_text)
    print("Vigen√®re Decrypted Text:", vigenere_decrypted_text)


if __name__ == '__main__':
    main()

"""# Implementation of **Gronsfield Cipher** :- 
 - Use online platform to use encryption and Decryption on this Link :- 
      üë®üèª‚Äçüíª [Generate Code](https://www.dcode.fr/gronsfeld-cipher) 

 - The Gronsfeld cipher is a variation of the Vigenere cipher in which a key number is used instead of a keyword, e.g., 14965. Usually the key does not contain repeated digits.

 - [REFERENCE](http://www.cs.trincoll.edu/~crypto/historical/gronsfeld.html) - to understand the implementation of Gronsfeld Cipher better and concise use this reference link.

# Time Complexity :-
The time complexity analysis of the provided code can be broken down into the following components:

[1] Iterating over the input plaintext or ciphertext:
- The code uses a for loop to iterate over each character in the plaintext or ciphertext. The loop runs for the length of the input text, which is¬†denoted¬†as¬†n.

[2] Searching for characters in the alphabet:

- The code checks if a character is present in the alphabet string using the in operator. This operation has a time complexity of **O(26)** since there are 26 characters in the alphabet.

[3] Indexing and shifting operations:

- The code performs indexing operations on the alphabet string to find the position of a character and calculate the shifted position. These operations have a constant time complexity of **O(1)** since the size of the alphabet string is fixed.

[4] Key-related operations:

- The key is converted to a string and stored in a variable. This conversion operation has a time complexity dependent on the length of the key, which 
can be denoted as k. The length of the key is typically much smaller 
compared to the length of the input text.

[5] Concatenation of characters:

- The code concatenates characters to build the resulting ciphertext or plaintext. The concatenation operation takes **O(1)** time complexity for each character added.

[6] Overall Time Complexity:
 - Overall, the time complexity of the encryption and decryption operations  in the GronsfeldCipher class can be analyzed as follows:

[6.1] Time Complexity of Encryption:
- The encryption process iterates over each character in the plaintext (n iterations). The operations performed within the loop (e.g., searching, indexing, shifting) have constant time complexity. Therefore, the overall time complexity of the encryption process is **O(n)**.

[6.2] Time Complexity of Decryption:
- The decryption process iterates over each character in the ciphertext (n iterations). The operations performed within the loop (e.g., searching, indexing, shifting) have constant time complexity.

--------------------------------

Therefore, the overall time complexity of the decryption process is **O(n)**.
It's important to note that the time complexity analysis assumes that the length of the key (k) is small compared to the length of the input text (n). 
If the key length becomes comparable or larger than the input text 
length, the time complexity would be influenced by the key-related 
operations as well.

In summary, **the time complexity of the provided code is O(n), where n is 
the length of the input plaintext or ciphertext**. 

"""

class GronsfeldCipher:
    def __init__(self):
        self.alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

    def encrypt(self, plaintext, key):
        ciphertext = ''
        plaintext = plaintext.upper()
        key = str(key)
        key_index = 0

        for char in plaintext:
            if char in self.alphabet:
                shift = int(key[key_index % len(key)])
                encrypted_char = self.alphabet[(self.alphabet.index(char) + shift) % 26]
                ciphertext += encrypted_char
                key_index += 1
            else:
                ciphertext += char

        return ciphertext

    def decrypt(self, ciphertext, key):
        plaintext = ''
        ciphertext = ciphertext.upper()
        key = str(key)
        key_index = 0

        for char in ciphertext:
            if char in self.alphabet:
                shift = int(key[key_index % len(key)])
                decrypted_char = self.alphabet[(self.alphabet.index(char) - shift) % 26]
                plaintext += decrypted_char
                key_index += 1
            else:
                plaintext += char

        return plaintext


def main():
    cipher = GronsfeldCipher()

    plaintext = "give me a call"
    key = 7827571449

    encrypted_text = cipher.encrypt(plaintext, key)
    decrypted_text = cipher.decrypt(encrypted_text, key)

    print("Plaintext:", plaintext)
    print("Encrypted Text:", encrypted_text)
    print("Decrypted Text:", decrypted_text)


if __name__ == '__main__':
    main()

"""# Cyyptographic Algorithms for Communication System :-

-  Developed by Group-IV [B.TECH CSE Final Year]



"""

class PolybiusCipher:
    def __init__(self):
        self.polybius_square = [['A', 'B', 'C', 'D', 'E'],
                                ['F', 'G', 'H', 'I', 'K'],
                                ['L', 'M', 'N', 'O', 'P'],
                                ['Q', 'R', 'S', 'T', 'U'],
                                ['V', 'W', 'X', 'Y', 'Z']]

    def encrypt(self, plaintext):
        ciphertext = ''
        plaintext = plaintext.upper()

        for char in plaintext:
            if char == 'J':
                char = 'I'
            for i in range(len(self.polybius_square)):
                if char in self.polybius_square[i]:
                    row = i + 1
                    col = self.polybius_square[i].index(char) + 1
                    ciphertext += str(row) + str(col)
                    break

        return ciphertext

    def decrypt(self, ciphertext):
        plaintext = ''
        ciphertext = ciphertext.upper()

        for i in range(0, len(ciphertext), 2):
            row = int(ciphertext[i])
            col = int(ciphertext[i + 1])
            plaintext += self.polybius_square[row - 1][col - 1]

        return plaintext


class VigenereCipher:
    def __init__(self, key):
        self.key = key.upper()

    def encrypt(self, plaintext):
        ciphertext = ''
        plaintext = plaintext.upper()
        key_index = 0

        for char in plaintext:
            if char.isalpha():
                shift = ord(self.key[key_index]) - ord('A')
                encrypted_char = chr((ord(char) + shift - 2 * ord('A')) % 26 + ord('A'))
                ciphertext += encrypted_char

                key_index = (key_index + 1) % len(self.key)

        return ciphertext

    def decrypt(self, ciphertext):
        plaintext = ''
        ciphertext = ciphertext.upper()
        key_index = 0

        for char in ciphertext:
            if char.isalpha():
                shift = ord(self.key[key_index]) - ord('A')
                decrypted_char = chr((ord(char) - shift - 2 * ord('A')) % 26 + ord('A'))
                plaintext += decrypted_char

                key_index = (key_index + 1) % len(self.key)

        return plaintext


class GronsfeldCipher:
    def __init__(self, key):
        self.key = key

    def encrypt(self, plaintext):
        ciphertext = ''
        plaintext = plaintext.upper()
        key_index = 0

        for char in plaintext:
            if char.isalpha():
                shift = int(self.key[key_index])
                encrypted_char = chr((ord(char) + shift - ord('A')) % 26 + ord('A'))
                ciphertext += encrypted_char

                key_index = (key_index + 1) % len(self.key)

        return ciphertext

    def decrypt(self, ciphertext):
        plaintext = ''
        ciphertext = ciphertext.upper()
        key_index = 0

        for char in ciphertext:
            if char.isalpha():
                shift = int(self.key[key_index])
                decrypted_char = chr((ord(char) - shift - ord('A')) % 26 + ord('A'))
                plaintext += decrypted_char

                key_index = (key_index + 1) % len(self.key)

        return plaintext


# INPUT TEXT :- 
polybius = PolybiusCipher()
vigenere = VigenereCipher("KEY")
gronsfeld = GronsfeldCipher("31415")

plaintext = "Urgent call"
polybius_ciphertext = polybius.encrypt(plaintext)
vigenere_ciphertext = vigenere.encrypt(polybius_ciphertext)
gronsfeld_ciphertext = gronsfeld.encrypt(vigenere_ciphertext)

print("Polybius Ciphertext:", polybius_ciphertext)
print("Vigenere Ciphertext:", vigenere_ciphertext)
print("Gronsfeld Ciphertext:", gronsfeld_ciphertext)

gronsfeld_plaintext = gronsfeld.decrypt(gronsfeld_ciphertext)
vigenere_plaintext = vigenere.decrypt(gronsfeld_plaintext)
polybius_plaintext = polybius.decrypt(vigenere_plaintext)

print("Polybius Plaintext:", polybius_plaintext)
print("Vigenere Plaintext:", vigenere_plaintext)
print("Gronsfeld Plaintext:", gronsfeld_plaintext)

"""```
# OUTPUT
Polybius Ciphertext: 1432412343
Vigenere Ciphertext: RFHKY
Gronsfeld Ciphertext: UIOOF
Polybius Plaintext: HELLO
Vigenere Plaintext: RFHKY
Gronsfeld Plaintext: UIOOF

```

- The Polybius ciphertext "1432412343" is obtained by replacing each letter in the plaintext "HELLO" with its corresponding coordinates in the Polybius square.

- The Vigenere ciphertext "RFHKY" is derived by encrypting the Polybius ciphertext using the Vigenere cipher with the key "KEY". Each letter of the Polybius ciphertext is shifted according to the corresponding letter in the key.

- The Gronsfeld ciphertext "UIOOF" is obtained by encrypting the Vigenere ciphertext using the Gronsfeld cipher with the key "31415". Each letter of the Vigenere ciphertext is shifted based on the corresponding digit in the key.

- To obtain the original plaintext, the decryption process is performed in reverse. The Gronsfeld ciphertext is decrypted using the Gronsfeld cipher, then the resulting Vigenere ciphertext is decrypted using the Vigenere cipher, and finally, the decrypted Polybius ciphertext is converted back to the original plaintext.

In this case, the decrypted Polybius ciphertext, Vigenere ciphertext, and Gronsfeld ciphertext all match the original plaintext "HELLO", indicating the successful decryption process.

#  Python code that implements a hybrid cryptographic algorithm using three ciphers:
- Caesar Cipher, Vigenere Cipher, and Rail Fence Cipher.
"""

class CaesarCipher:
    @staticmethod
    def encrypt(plaintext, shift):
        ciphertext = ""
        for char in plaintext:
            if char.isalpha():
                if char.islower():
                    encrypted_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a'))
                else:
                    encrypted_char = chr((ord(char) - ord('A') + shift) % 26 + ord('A'))
                ciphertext += encrypted_char
            else:
                ciphertext += char
        return ciphertext

    @staticmethod
    def decrypt(ciphertext, shift):
        plaintext = ""
        for char in ciphertext:
            if char.isalpha():
                if char.islower():
                    decrypted_char = chr((ord(char) - ord('a') - shift) % 26 + ord('a'))
                else:
                    decrypted_char = chr((ord(char) - ord('A') - shift) % 26 + ord('A'))
                plaintext += decrypted_char
            else:
                plaintext += char
        return plaintext


class VigenereCipher:
    @staticmethod
    def encrypt(plaintext, key):
        ciphertext = ""
        key = key.upper()
        key_index = 0

        for char in plaintext:
            if char.isalpha():
                if char.islower():
                    encrypted_char = chr(
                        (ord(char) - ord('a') + (ord(key[key_index]) - ord('A'))) % 26 + ord('a')
                    )
                else:
                    encrypted_char = chr(
                        (ord(char) - ord('A') + (ord(key[key_index]) - ord('A'))) % 26 + ord('A')
                    )
                ciphertext += encrypted_char

                key_index = (key_index + 1) % len(key)
            else:
                ciphertext += char

        return ciphertext

    @staticmethod
    def decrypt(ciphertext, key):
        plaintext = ""
        key = key.upper()
        key_index = 0

        for char in ciphertext:
            if char.isalpha():
                if char.islower():
                    decrypted_char = chr(
                        (ord(char) - ord('a') - (ord(key[key_index]) - ord('A'))) % 26 + ord('a')
                    )
                else:
                    decrypted_char = chr(
                        (ord(char) - ord('A') - (ord(key[key_index]) - ord('A'))) % 26 + ord('A')
                    )
                plaintext += decrypted_char

                key_index = (key_index + 1) % len(key)
            else:
                plaintext += char

        return plaintext


class RailFenceCipher:
    @staticmethod
    def encrypt(plaintext, rails):
        fence = [['\n' for _ in range(len(plaintext))] for _ in range(rails)]
        direction = -1
        row, col = 0, 0

        for char in plaintext:
            if row == 0 or row == rails - 1:
                direction *= -1

            fence[row][col] = char
            col += 1
            row += direction

        ciphertext = ""
        for row in fence:
            for char in row:
                if char != '\n':
                    ciphertext += char

        return ciphertext

    @staticmethod
    def decrypt(ciphertext, rails):
        fence = [['\n' for _ in range(len(ciphertext))] for _ in range(rails)]
        direction = -1
        row, col = 0, 0

        for _ in ciphertext:
            if row == 0 or row == rails - 1:
                direction *= -1

            fence[row][col] = '*'
            col += 1
            row += direction

        index = 0
        for row in range(rails):
            for col in range(len(ciphertext)):
                if fence[row][col] == '*' and index < len(ciphertext):
                    fence[row][col] = ciphertext[index]
                    index += 1

        plaintext = ""
        row, col = 0, 0
        direction = -1

        for _ in ciphertext:
            if row == 0 or row == rails - 1:
                direction *= -1

            if fence[row][col] != '*':
                plaintext += fence[row][col]

            col += 1
            row += direction

        return plaintext


# Input Text:
plaintext = "THis is 4th year Project"
caesar_shift = 3
vigenere_key = "KEY"
rail_fence_rails = 3

caesar_ciphertext = CaesarCipher.encrypt(plaintext, caesar_shift)
vigenere_ciphertext = VigenereCipher.encrypt(caesar_ciphertext, vigenere_key)
rail_fence_ciphertext = RailFenceCipher.encrypt(vigenere_ciphertext, rail_fence_rails)

print("Caesar Ciphertext:", caesar_ciphertext)
print("Vigenere Ciphertext:", vigenere_ciphertext)
print("Rail Fence Ciphertext:", rail_fence_ciphertext)

rail_fence_plaintext = RailFenceCipher.decrypt(rail_fence_ciphertext, rail_fence_rails)
vigenere_plaintext = VigenereCipher.decrypt(rail_fence_plaintext, vigenere_key)
caesar_plaintext = CaesarCipher.decrypt(vigenere_plaintext, caesar_shift)

print("Caesar Plaintext:", caesar_plaintext)
print("Vigenere Plaintext:", vigenere_plaintext)
print("Rail Fence Plaintext:", rail_fence_plaintext)

""" - **A hybrid algorithm code that combines the Polybius cipher, Vigen√®re cipher, and Gronsfeld cipher for a communication system**"""

# Polybius Cipher
def polybius_cipher(text):
    alphabet = "abcdefghijklmnopqrstuvwxyz"
    polybius_square = [
        ['A', 'B', 'C', 'D', 'E'],
        ['F', 'G', 'H', 'I', 'K'],
        ['L', 'M', 'N', 'O', 'P'],
        ['Q', 'R', 'S', 'T', 'U'],
        ['V', 'W', 'X', 'Y', 'Z']
    ]
    encrypted_text = ""

    for char in text.upper():
        if char in alphabet:
            for i in range(5):
                for j in range(5):
                    if polybius_square[i][j] == char:
                        encrypted_text += str(i + 1) + str(j + 1)
        else:
            encrypted_text += char

    return encrypted_text


# Vigen√®re Cipher
def vigenere_cipher(text, key):
    alphabet = "abcdefghijklmnopqrstuvwxyz"
    key = key.lower()
    encrypted_text = ""

    for i, char in enumerate(text):
        if char in alphabet:
            key_shift = alphabet.index(key[i % len(key)])
            char_shift = alphabet.index(char)
            encrypted_char = alphabet[(char_shift + key_shift) % 26]
            encrypted_text += encrypted_char
        else:
            encrypted_text += char

    return encrypted_text


# Gronsfeld Cipher
def gronsfeld_cipher(text, key):
    alphabet = "abcdefghijklmnopqrstuvwxyz"
    key = str(key)
    encrypted_text = ""

    for i, char in enumerate(text):
        if char in alphabet:
            key_shift = int(key[i % len(key)])
            char_shift = alphabet.index(char)
            encrypted_char = alphabet[(char_shift + key_shift) % 26]
            encrypted_text += encrypted_char
        else:
            encrypted_text += char

    return encrypted_text


# Input Text :-
plaintext = "Please call me back"
polybius_key = "primary"
vigenere_key = "secondary"
gronsfeld_key = 52714

# Encryption
polybius_encrypted = polybius_cipher(plaintext)
vigenere_encrypted = vigenere_cipher(polybius_encrypted, vigenere_key)
gronsfeld_encrypted = gronsfeld_cipher(vigenere_encrypted, gronsfeld_key)
print("Encrypted text:", gronsfeld_encrypted)

# Decryption
gronsfeld_decrypted = gronsfeld_cipher(gronsfeld_encrypted, -gronsfeld_key)  
# Using negative key to decrypt
vigenere_decrypted = vigenere_cipher(gronsfeld_decrypted, vigenere_key)
polybius_decrypted = polybius_cipher(vigenere_decrypted)
print("Decrypted text:", polybius_decrypted)

"""-  Using random we can generate the key for encryption .

"""

import random

def generate_key(length):
    key = ""
    for _ in range(length):
        key += str(random.randint(0, 9))
    return key

def polybius_encrypt(message):
    key = "ABCDEFGHIKLMNOPQRSTUVWXYZ"
    table = [['A', 'B', 'C', 'D', 'E'],
             ['F', 'G', 'H', 'I', 'K'],
             ['L', 'M', 'N', 'O', 'P'],
             ['Q', 'R', 'S', 'T', 'U'],
             ['V', 'W', 'X', 'Y', 'Z']]

    encrypted_message = ""
    for char in message:
        if char == 'J':
            char = 'I'
        char = char.upper()
        for i in range(len(table)):
            if char in table[i]:
                row = i + 1
                col = table[i].index(char) + 1
                encrypted_message += str(row) + str(col)
                break
    return encrypted_message

def polybius_decrypt(encrypted_message):
    key = "ABCDEFGHIKLMNOPQRSTUVWXYZ"
    table = [['A', 'B', 'C', 'D', 'E'],
             ['F', 'G', 'H', 'I', 'K'],
             ['L', 'M', 'N', 'O', 'P'],
             ['Q', 'R', 'S', 'T', 'U'],
             ['V', 'W', 'X', 'Y', 'Z']]

    decrypted_message = ""
    i = 0
    while i < len(encrypted_message):
        row = int(encrypted_message[i])
        col = int(encrypted_message[i + 1])
        decrypted_message += table[row - 1][col - 1]
        i += 2
    return decrypted_message

def vigenere_encrypt(message, key):
    key = key.upper()
    encrypted_message = ""
    for i in range(len(message)):
        char = message[i]
        if char.isalpha():
            key_index = i % len(key)
            key_char = key[key_index]
            key_shift = ord(key_char) - ord('A')
            encrypted_char = chr((ord(char) + key_shift - 65) % 26 + 65)
            encrypted_message += encrypted_char
        else:
            encrypted_message += char
    return encrypted_message

def vigenere_decrypt(encrypted_message, key):
    key = key.upper()
    decrypted_message = ""
    for i in range(len(encrypted_message)):
        char = encrypted_message[i]
        if char.isalpha():
            key_index = i % len(key)
            key_char = key[key_index]
            key_shift = ord(key_char) - ord('A')
            decrypted_char = chr((ord(char) - key_shift - 65) % 26 + 65)
            decrypted_message += decrypted_char
        else:
            decrypted_message += char
    return decrypted_message

def gronsfeld_encrypt(message, key):
    key_length = len(key)
    encrypted_message = ""
    for i in range(len(message)):
        char = message[i]
        if char.isalpha():
            key_index = i % key_length
            key_digit = int(key[key_index])
            char_shift = ord(char) - ord('A')
            encrypted_char = chr((char_shift + key_digit) % 26 + 65)
            encrypted_message += encrypted_char
        else:
            encrypted_message += char
    return encrypted_message

def gronsfeld_decrypt(encrypted_message, key):
    key_length = len(key)
    decrypted_message = ""
    for i in range(len(encrypted_message)):
        char = encrypted_message[i]
        if char.isalpha():
            key_index = i % key_length
            key_digit = int(key[key_index])
            char_shift = ord(char) - ord('A')
            decrypted_char = chr((char_shift - key_digit) % 26 + 65)
            decrypted_message += decrypted_char
        else:
            decrypted_message += char
    return decrypted_message

#Input Text :-
message = "Call me back ASAP"
polybius_key = generate_key(5)
vigenere_key = "KEY"
gronsfeld_key = "31415"

#Encryption :-
polybius_encrypted = polybius_encrypt(message)
vigenere_encrypted = vigenere_encrypt(polybius_encrypted, vigenere_key)
encrypted_message = gronsfeld_encrypt(vigenere_encrypted, gronsfeld_key)

print("Encrypted message:", encrypted_message)

# Decryption
decrypted_message = gronsfeld_decrypt(encrypted_message, gronsfeld_key)
vigenere_decrypted = vigenere_decrypt(decrypted_message, vigenere_key)
polybius_decrypted = polybius_decrypt(vigenere_decrypted)

print("Decrypted message:", polybius_decrypted)

"""# Time Complexity of A hybrid algorithm code that combines the Polybius cipher, Vigen√®re cipher, and Gronsfeld cipher for a communication system

[1] generate_key(length):
- This function generates a random key of length length. The time complexity of generating a random key is O(length).

[2] polybius_encrypt(message):
- This function encrypts the message using the Polybius cipher. The time complexity depends on the length of the message. For each character in the message, we perform a constant amount of operations to find the corresponding Polybius cipher value. Therefore, the time complexity is **O(n)**, where n is the length of the message.

[3] polybius_decrypt(encrypted_message): 
- This function decrypts the encrypted message using the Polybius cipher. Similar to the encryption process, we iterate over each pair of digits in the encrypted message and perform a constant amount of operations to retrieve the corresponding character. The time complexity is also **O(n)**,where n is the length of the encrypted message.

[4] vigenere_encrypt(message, key): 
- This function encrypts the message using the Vigen√®re cipher. It iterates over each character in the message and performs a constant amount of operations to determine the shift value based on the corresponding character in the key. Thus, the time complexity is **O(n)**, where n is the length of the message.

[5] vigenere_decrypt(encrypted_message, key):
- This function decrypts the encrypted message using the Vigen√®re cipher. Similar to encryption, it iterates over each character in the encrypted message and performs a constant amount of operations to determine the shift value based on the corresponding character in the key. Hence, the time complexity is **O(n)**, where n is the length of the encrypted message.

[6] gronsfeld_encrypt(message, key): 
- This function encrypts the message using the Gronsfeld cipher. It iterates over each character in the message and performs a constant amount of operations to determine the shift value based on the corresponding digit in the key. Thus, the time complexity is **O(n)**, where n is the length of the message.

[7] gronsfeld_decrypt(encrypted_message, key):
- This function decrypts the encrypted message using the Gronsfeld cipher. Similar to encryption, it iterates over each character in the encrypted message and performs a constant amount of operations to determine the shift value based on the corresponding digit in the key. Therefore, the time complexity is **O(n)**, where n is the length of the encrypted message.

-----------------------------------

**Overall, the time complexity of the given code is dominated by the length of the input message or encrypted message, depending on the operation being performed. Thus, the overall time complexity of the code can be considered 
as O(n), where n is the length of the input message or encrypted message, whichever is larger**.
"""